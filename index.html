<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ろ紙ろ過・重量ログ 可視化（最長線形区間）</title>
  <link rel="icon" href="favicon.ico" sizes="any">
  <link rel="icon" type="image/png" href="favicon.png">
  <link rel="stylesheet" href="index.css" />
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
</head>
<body>
  <header class="app-header" role="banner">
    <div class="brandbar"></div>
    <div class="container header-inner">
      <div class="titleblock">
        <h1 class="app-title">ろ紙ろ過・重量ログ 可視化</h1>
        <p class="app-subtitle">横軸：経過時間(s)／縦軸：重量(g)　|　<strong>最長線形区間</strong>（R²・n条件）と傾きa[g/s]を自動算出</p>
      </div>
    </div>
  </header>

  <main class="container" role="main">
    <section class="panel" aria-label="Input and settings">
      <div class="panel-head">
        <h2 class="panel-title">データ読み込み</h2>
        <p class="panel-note">CSV（weight_log.csv など）を選択してください。開始点 tₛ は <b>ファイルごと</b>に設定できます。重ね描き時は各 tₛ を 0 秒として揃えて表示します。</p>
      </div>

      <div class="controls">
        <div class="file-picker">
          <span class="label">CSVファイル</span>
          <div class="file-row">
            <label class="file-btn" for="fileInput">
              <span class="file-btn-icon" aria-hidden="true">⭳</span>
              <span class="file-btn-text">ファイル選択</span>
            </label>
            <input type="file" id="fileInput" accept=".csv" multiple />
            <div class="file-meta" aria-live="polite">
              <span id="fileNames" class="file-names">未選択</span>
              <span class="file-hint">（複数可）</span>
            </div>
          </div>
          <div class="microhint">ヒント：グラフ上の点をクリックすると、そのファイルの開始点 tₛ をクリック位置にセットできます（重ね描きでもOK）</div>
        </div>

        <div class="toggle-group" role="group" aria-label="Plot options">
          <label class="toggle">
            <input type="checkbox" id="overlay" checked />
            <span>重ね描き（各tₛ=0に整列）</span>
          </label>
          <label class="toggle">
            <input type="checkbox" id="markers" />
            <span>マーカー</span>
          </label>
        </div>

        <button id="resetZoom" class="btn btn-ghost" type="button">ズームリセット</button>
      </div>

      <div class="settings">
        <div class="setting">
          <label for="minN">最小点数 n ≥</label>
          <input type="number" id="minN" min="2" step="1" value="5" />
        </div>
        <div class="setting">
          <label for="minR2">決定係数 R² ≥</label>
          <input type="number" id="minR2" min="0" max="1" step="0.01" value="0.95" />
        </div>
        <div class="setting">
          <label for="stepT">候補T刻み Δt (s)</label>
          <input type="number" id="stepT" min="1" step="1" value="1" />
        </div>
        <button id="reanalyze" class="btn btn-primary" type="button">再計算</button>
      </div>

      <details class="details">
        <summary>評価条件（ファイルごと開始点）</summary>
        <div class="details-body">
          <p class="muted">各ファイルについて、開始点 <code>tₛ</code> を個別に設定し、評価区間 <code>tₛ ≤ t ≤ T</code> で一次回帰 <code>y = a t + b</code> を実行します。条件 <code>n ≥ n_min</code> かつ <code>R² ≥ R²_min</code> を満たす範囲のうち最大Tを「最長線形区間」とします。候補Tは Δt 刻み（既定 1s）です。</p>
        </div>
      </details>
    </section>

    <section class="summary" aria-label="Results">
      <div id="summary"></div>
    </section>

    <!-- ★追加：計算結果 表 -->
    <section class="panel" aria-label="計算結果表" style="margin-top:14px;">
      <div class="panel-head">
        <h2 class="panel-title">計算結果（表）</h2>
        <p class="panel-note">各ファイルの「最長線形区間」結果を、指定フォーマット（系列 / T[s] / n / a / b / R²）で一覧表示します。</p>
      </div>

      <div class="controls" style="justify-content:flex-start; gap:10px;">
        <button id="btnCopyTSV" class="btn btn-ghost" type="button">TSVコピー（Excel貼付）</button>
        <button id="btnDownloadCSV" class="btn btn-ghost" type="button">CSVダウンロード</button>
      </div>

      <div style="overflow:auto; margin-top:10px;">
        <table id="resultTable" border="1" cellspacing="0" cellpadding="6"
               style="border-collapse:collapse; min-width:760px; background:#fff;">
          <thead>
            <tr style="background:#f4f4f4;">
              <th>系列</th>
              <th>T[s]</th>
              <th>n</th>
              <th>傾き a [g/s]</th>
              <th>切片 b [g]</th>
              <th>R²</th>
            </tr>
          </thead>
          <tbody><!-- JSで行を挿入 --></tbody>
        </table>
      </div>
    </section>

    <section class="charts" aria-label="Charts">
      <div id="plot" class="plot"></div>
      <div id="plots" class="plots"></div>
    </section>
  </main>

  <footer class="app-footer" role="contentinfo">
    <div class="container footer-inner">
      <small class="muted">ローカルで動作します（ブラウザ内で読み込み・解析・描画。ファイルは外部へ送信されません）。</small>
    </div>
  </footer>

<script>
  const COLORS = ['#00a8a9', '#cbaf00', '#e39300', '#d35344', '#72af2d', '#0074b0', '#5f7fb1', '#7f7f7f'];

  const fileInput = document.getElementById('fileInput');
  const fileNames = document.getElementById('fileNames');

  let lastFiles = [];
  let startByName = {}; // { fileName: tStart }

  function updateFileNames() {
    const files = Array.from(fileInput.files || []);
    if (!files.length) { fileNames.textContent = '未選択'; return; }
    const names = files.map(f => f.name);
    const head = names.slice(0, 3).join(' / ');
    const tail = names.length > 3 ? ` ほか${names.length - 3}件` : '';
    fileNames.textContent = head + tail;
  }

  function parseCSV(text) {
    const lines = text.split(/\r?\n/).filter(l => l.trim().length);
    if (lines.length === 0) return { rows: [], header: [] };

    const header = lines[0].split(',').map(s => s.trim());
    const idxElapsed = header.findIndex(h => h.toLowerCase() === 'elapsed_s');
    const idxWeight  = header.findIndex(h => h.toLowerCase() === 'weight_g');
    const idxTs       = header.findIndex(h => h.toLowerCase() === 'timestamp');
    const hasNamed = (idxElapsed >= 0 && idxWeight >= 0);

    const rows = [];
    for (let i = 1; i < lines.length; i++) {
      const cols = lines[i].split(',').map(s => s.trim());
      if (cols.length < 2) continue;

      let elapsed, weight, ts;
      if (hasNamed) {
        elapsed = parseFloat(cols[idxElapsed]);
        weight  = parseFloat(cols[idxWeight]);
        ts      = (idxTs >= 0) ? cols[idxTs] : '';
      } else {
        ts = cols[0] ?? '';
        elapsed = parseFloat(cols[1]);
        weight  = parseFloat(cols[3]);
      }
      if (!Number.isFinite(elapsed) || !Number.isFinite(weight)) continue;
      rows.push({ elapsed, weight, ts });
    }
    rows.sort((a,b) => a.elapsed - b.elapsed);
    return { rows, header };
  }

  function linreg(x, y) {
    const n = x.length;
    if (n < 2) return null;

    const meanX = x.reduce((a,b)=>a+b,0) / n;
    const meanY = y.reduce((a,b)=>a+b,0) / n;

    let sxx = 0, sxy = 0, syy = 0;
    for (let i=0; i<n; i++) {
      const dx = x[i] - meanX;
      const dy = y[i] - meanY;
      sxx += dx*dx;
      sxy += dx*dy;
      syy += dy*dy;
    }
    if (sxx === 0) return null;

    const a = sxy / sxx;
    const b = meanY - a*meanX;

    let sse = 0;
    for (let i=0; i<n; i++) {
      const yhat = a*x[i] + b;
      const e = y[i] - yhat;
      sse += e*e;
    }
    const sst = syy;
    const r2 = (sst === 0) ? 1 : (1 - (sse / sst));

    return { a, b, r2, n };
  }

  function ceilToStep(x, step) { return Math.ceil(x / step) * step; }
  function clampStartToData(tStart, maxElapsed) {
    if (!Number.isFinite(tStart)) return 0;
    return Math.min(Math.max(0, tStart), Math.max(0, maxElapsed));
  }

  function findLongestLinearInterval(rows, tStart, stepT, minN, minR2) {
    if (!rows.length) return null;
    const maxT = rows[rows.length-1].elapsed;
    const start = clampStartToData(tStart, maxT);
    const firstT = Math.max(start, ceilToStep(start, stepT));

    let best = null;
    for (let T = firstT; T <= maxT + 1e-9; T += stepT) {
      const sub = rows.filter(r => r.elapsed >= start - 1e-9 && r.elapsed <= T + 1e-9);
      if (sub.length < minN) continue;
      const x = sub.map(r => r.elapsed);
      const y = sub.map(r => r.weight);
      const reg = linreg(x, y);
      if (!reg) continue;
      if (reg.r2 >= minR2) best = { tStart: start, T, ...reg, x0: start, x1: T };
    }
    return best;
  }

  function buildTrace(it, showMarkers, alignToStart) {
    const x = it.rows.map(r => alignToStart ? (r.elapsed - it.tStart) : r.elapsed);
    const y = it.rows.map(r => r.weight);
    const custom = it.rows.map(r => [r.elapsed, r.ts || '']);

    return {
      x,
      y,
      customdata: custom,
      type: 'scatter',
      mode: showMarkers ? 'lines+markers' : 'lines',
      name: it.name,
      meta: { fileKey: it.name },
      line: { color: it.color, width: 2 },
      marker: { color: it.color, size: 5 },
      hovertemplate:
        (alignToStart ? '開始点基準: %{x:.0f}s<br>' : '経過時間: %{x:.0f}s<br>') +
        '重量: %{y:.2f} g<br>' +
        '元の時刻: %{customdata[0]:.0f}s<br>' +
        '%{customdata[1]}<extra>' + it.name + '</extra>'
    };
  }

  function buildFitTrace(it, alignToStart) {
    const best = it.best;
    if (!best) return null;

    if (alignToStart) {
      const x = [0, best.T - best.tStart];
      const y0 = best.a * best.tStart + best.b;
      const y1 = best.a * best.T + best.b;
      return {
        x, y: [y0, y1],
        type: 'scatter', mode: 'lines',
        name: `${it.name} 回帰(0–${(best.T-best.tStart).toFixed(0)}s)`,
        meta: { fileKey: it.name },
        line: { color: it.color, width: 3, dash: 'dash' },
        hovertemplate:
          `tₛ=${best.tStart.toFixed(0)}s / T=${best.T.toFixed(0)}s<br>` +
          `a=${best.a.toFixed(6)} g/s<br>` +
          `b=${best.b.toFixed(3)} g<br>` +
          `R²=${best.r2.toFixed(4)} / n=${best.n}<extra>${it.name}</extra>`
      };
    } else {
      const x = [best.x0, best.x1];
      const y = x.map(t => best.a*t + best.b);
      return {
        x, y,
        type: 'scatter', mode: 'lines',
        name: `${it.name} 回帰(${best.tStart.toFixed(0)}–${best.T.toFixed(0)}s)`,
        meta: { fileKey: it.name },
        line: { color: it.color, width: 3, dash: 'dash' },
        hovertemplate:
          `tₛ=${best.tStart.toFixed(0)}s / T=${best.T.toFixed(0)}s<br>` +
          `a=${best.a.toFixed(6)} g/s<br>` +
          `b=${best.b.toFixed(3)} g<br>` +
          `R²=${best.r2.toFixed(4)} / n=${best.n}<extra>${it.name}</extra>`
      };
    }
  }

  function computeStats(rows) {
    const ys = rows.map(r => r.weight);
    const min = Math.min(...ys);
    const max = Math.max(...ys);
    const mean = ys.reduce((a,b)=>a+b,0) / ys.length;
    const t0 = rows[0]?.elapsed ?? 0;
    const t1 = rows[rows.length-1]?.elapsed ?? 0;
    return { min, max, mean, t0, t1, n: rows.length };
  }

  // ★修正：正しいHTMLエスケープ（安全のため）
  function escapeHtml(str) {
    return String(str)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#39;');
  }

  function renderSummary(items, minN, minR2) {
    const div = document.getElementById('summary');
    if (!items.length) { div.innerHTML = ''; return; }

    const html = items.map((it) => {
      const s = it.stats;
      const best = it.best;
      const tStart = it.tStart;

      const bestHtml = best ?
        `<div class="kv"><span class="k">開始点 tₛ</span><span class="v">${best.tStart.toFixed(0)} s</span></div>
         <div class="kv"><span class="k">最長線形区間 T</span><span class="v">${best.T.toFixed(0)} s</span></div>
         <div class="kv"><span class="k">傾き a</span><span class="v">${best.a.toFixed(6)} g/s</span></div>
         <div class="kv"><span class="k">当てはまり</span><span class="v">R² ${best.r2.toFixed(4)} / n ${best.n}</span></div>`
        :
        `<div class="warn">条件（tₛ=${tStart.toFixed(0)}s, n≥${minN}, R²≥${minR2}）を満たす区間が見つかりませんでした。</div>`;

      return `
        <article class="card">
          <header class="card-head">
            <span class="swatch" style="background:${it.color}"></span>
            <div class="card-title">${escapeHtml(it.name)}</div>
          </header>
          <div class="card-body">
            <div class="meta">点数 ${s.n} ／ 時間 ${s.t0.toFixed(0)}–${s.t1.toFixed(0)}s ／ 重量 min ${s.min.toFixed(2)} g・mean ${s.mean.toFixed(2)} g・max ${s.max.toFixed(2)} g</div>
            <div class="card-controls">
              <label class="mini-label">開始点 tₛ (s)</label>
              <input class="mini-input" type="number" min="0" step="1" value="${Math.round(tStart)}" data-file="${escapeHtml(it.name)}" />
              <span class="mini-note">※このファイルだけに適用</span>
            </div>
            <div class="divider"></div>
            ${bestHtml}
          </div>
        </article>`;
    }).join('');

    div.innerHTML = `<div class="cards">${html}</div>`;

    div.querySelectorAll('input.mini-input').forEach(inp => {
      inp.addEventListener('change', async (e) => {
        const key = e.target.getAttribute('data-file');
        const v = parseFloat(e.target.value);
        startByName[key] = Number.isFinite(v) ? v : 0;
        if (lastFiles.length) await analyzeAndPlot(lastFiles);
      });
    });
  }

  function plotLayoutBase(title, overlayMode) {
    const shapes = [];
    if (overlayMode) {
      // aligned zero line
      shapes.push({
        type: 'line', xref: 'x', yref: 'paper',
        x0: 0, x1: 0,
        y0: 0, y1: 1,
        line: { color: '#00a8a9', width: 1, dash: 'dot' }
      });
    }

    return {
      title: { text: title, y: 0.97 },
      paper_bgcolor: '#ffffff',
      plot_bgcolor: '#ffffff',
      font: { family: getComputedStyle(document.body).fontFamily, color: '#111111' },
      xaxis: {
        title: overlayMode ? '経過時間（開始点基準, s）' : '経過時間 (s)',
        zeroline: false,
        gridcolor: '#e6e9ef',
        linecolor: '#c8ceda',
        tickcolor: '#c8ceda'
      },
      yaxis: {
        title: '重量 (g)',
        zeroline: false,
        gridcolor: '#e6e9ef',
        linecolor: '#c8ceda',
        tickcolor: '#c8ceda'
      },
      margin: { t: 60, r: 24, b: 56, l: 70 },
      legend: { orientation: 'h', bgcolor: 'rgba(255,255,255,0.8)' },
      shapes
    };
  }

  function attachClickToSetStart(plotDiv) {
    if (!plotDiv || !plotDiv.on) return;
    plotDiv.removeAllListeners?.('plotly_click');
    plotDiv.on('plotly_click', async (ev) => {
      const pt = ev?.points?.[0];
      const x = pt?.x;
      const fileKey = pt?.data?.meta?.fileKey;
      if (!Number.isFinite(x) || !fileKey) return;

      const overlayMode = document.getElementById('overlay').checked;
      const current = startByName[fileKey] ?? 0;
      const newStart = overlayMode ? Math.max(0, Math.round(current + x)) : Math.max(0, Math.round(x));

      startByName[fileKey] = newStart;
      const cardInput = document.querySelector(`input.mini-input[data-file="${CSS.escape(fileKey)}"]`);
      if (cardInput) cardInput.value = String(newStart);

      if (lastFiles.length) await analyzeAndPlot(lastFiles);
    });
  }

  function plotOverlay(items, showMarkers) {
    const traces = [];
    items.forEach((it) => {
      traces.push(buildTrace(it, showMarkers, true));
      const fit = buildFitTrace(it, true);
      if (fit) traces.push(fit);
    });

    Plotly.newPlot('plot', traces, plotLayoutBase('重量 vs 経過時間（重ね描き：開始点整列）', true), { responsive: true }).then(() => {
      attachClickToSetStart(document.getElementById('plot'));
    });
    document.getElementById('plots').innerHTML = '';
  }

  function plotSeparate(items, showMarkers) {
    Plotly.purge('plot');
    document.getElementById('plot').innerHTML = '';

    const container = document.getElementById('plots');
    container.innerHTML = '';

    items.forEach((it) => {
      const div = document.createElement('div');
      div.className = 'plot';
      container.appendChild(div);

      const traces = [buildTrace(it, showMarkers, false)];
      const fit = buildFitTrace(it, false);
      if (fit) traces.push(fit);

      Plotly.newPlot(div, traces, plotLayoutBase(it.name, false), { responsive: true }).then(() => {
        attachClickToSetStart(div);
      });
    });
  }

  async function readFile(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsText(file);
    });
  }

  function getSelectedFiles() { return Array.from(fileInput.files || []); }

  // === 計算結果 表出力（系列 / T[s] / n / a / b / R²） ===================

  function seriesLabelFromFileName(fileName) {
    const base = String(fileName || '').replace(/\.[^.]+$/, ''); // 拡張子除去
    return base
      .replace(/mgL/gi, 'mg/L')
      .replace(/mg\/l/gi, 'mg/L');
  }

  function renderResultTable(items) {
    const table = document.getElementById('resultTable');
    if (!table) return;

    const tbody = table.querySelector('tbody');
    tbody.innerHTML = '';

    const fmtInt = (v) => Number.isFinite(v) ? String(Math.round(v)) : '';
    const fmt2   = (v) => Number.isFinite(v) ? v.toFixed(2) : '';

    items.forEach(it => {
      const best = it.best;

      // T[s] は「最長線形区間の長さ」を採用（T - tₛ）
      // ★もし「絶対時間のT」を出したいなら、次行を `const Tval = best ? best.T : NaN;` に変更
      const Tval = best ? (best.T - best.tStart) : NaN;

      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${escapeHtml(seriesLabelFromFileName(it.name))}</td>
        <td style="text-align:right;">${fmtInt(Tval)}</td>
        <td style="text-align:right;">${best ? fmtInt(best.n) : ''}</td>
        <td style="text-align:right;">${best ? fmt2(best.a) : ''}</td>
        <td style="text-align:right;">${best ? fmt2(best.b) : ''}</td>
        <td style="text-align:right;">${best ? fmt2(best.r2) : ''}</td>
      `;
      tbody.appendChild(tr);
    });
  }

  function tableToTSV() {
    const table = document.getElementById('resultTable');
    if (!table) return '';
    const rows = Array.from(table.querySelectorAll('tr')).map(tr => {
      const cols = Array.from(tr.children).map(td => td.innerText.replace(/\r?\n/g, ' '));
      return cols.join('\t');
    });
    return rows.join('\n');
  }

  function copyResultTSV() {
    const tsv = tableToTSV();
    if (!tsv) return;
    navigator.clipboard?.writeText(tsv);
  }

  function downloadResultCSV(filename = 'calculation_results.csv') {
    const table = document.getElementById('resultTable');
    if (!table) return;

    const rows = Array.from(table.querySelectorAll('tr')).map(tr => {
      const cols = Array.from(tr.children).map(td => {
        const s = td.innerText.replace(/\r?\n/g, ' ');
        return `"${s.replace(/"/g, '""')}"`;
      });
      return cols.join(',');
    });

    const csv = rows.join('\n');
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  document.getElementById('btnCopyTSV')?.addEventListener('click', copyResultTSV);
  document.getElementById('btnDownloadCSV')?.addEventListener('click', () => downloadResultCSV());

  // ======================================================================

  async function analyzeAndPlot(files) {
    const overlayMode = document.getElementById('overlay').checked;
    const showMarkers = document.getElementById('markers').checked;

    const minN = parseInt(document.getElementById('minN').value, 10) || 5;
    const minR2 = parseFloat(document.getElementById('minR2').value);
    const stepT = parseFloat(document.getElementById('stepT').value) || 1;

    const items = [];

    for (let i=0; i<files.length; i++) {
      const f = files[i];
      const text = await readFile(f);
      const { rows } = parseCSV(text);
      if (!rows.length) continue;

      const maxElapsed = rows[rows.length - 1].elapsed;
      const tStart = clampStartToData((startByName[f.name] ?? 0), maxElapsed);
      startByName[f.name] = tStart;

      const best = findLongestLinearInterval(rows, tStart, stepT, minN, minR2);

      items.push({
        name: f.name,
        rows,
        stats: computeStats(rows),
        tStart,
        best,
        color: COLORS[i % COLORS.length]
      });
    }

    if (!items.length) {
      alert('有効なデータ行が見つかりませんでした。CSVの列（elapsed_s, weight_g）を確認してください。');
      return;
    }

    renderSummary(items, minN, minR2);
    renderResultTable(items); // ★追加：表の更新

    if (overlayMode) plotOverlay(items, showMarkers);
    else plotSeparate(items, showMarkers);
  }

  // Events
  fileInput.addEventListener('change', async () => {
    updateFileNames();
    lastFiles = getSelectedFiles();
    lastFiles.forEach(f => { if (startByName[f.name] === undefined) startByName[f.name] = 0; });
    if (lastFiles.length) await analyzeAndPlot(lastFiles);
  });

  document.getElementById('overlay').addEventListener('change', async () => {
    if (lastFiles.length) await analyzeAndPlot(lastFiles);
  });

  document.getElementById('markers').addEventListener('change', async () => {
    if (lastFiles.length) await analyzeAndPlot(lastFiles);
  });

  document.getElementById('reanalyze').addEventListener('click', async () => {
    lastFiles = getSelectedFiles();
    if (lastFiles.length) await analyzeAndPlot(lastFiles);
  });

  document.getElementById('resetZoom').addEventListener('click', () => {
    const plotDiv = document.getElementById('plot');
    if (plotDiv && plotDiv.data) {
      Plotly.relayout(plotDiv, { 'xaxis.autorange': true, 'yaxis.autorange': true });
    }
    document.querySelectorAll('#plots .plot').forEach(div => {
      if (div && div.data) {
        Plotly.relayout(div, { 'xaxis.autorange': true, 'yaxis.autorange': true });
      }
    });
  });
</script>
</body>
</html>
